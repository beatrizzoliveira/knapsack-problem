# -*- coding: utf-8 -*-
"""knapsack_problem

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Msagt3GIivsytIVbO1A-VNKGNOwjOC3H

# Tópico 2 - Problema da Mochila (Knapsack Problem)


Dado um conjunto de itens, cada um com um peso ($w_i$) e um valor ($v_i$) associado, o objetivo é determinar a combinação de itens a ser colocada numa mochila com capacidade limitada ($W$), de modo a maximizar o valor total dos itens, sem exceder a capacidade da mochila.

Formalmente, seja ( $n$) o número de itens, ( $w_i$) o peso do item ( $i$), ($v_i$) o valor do item ($i$), e ($W$) a capacidade da mochila. O problema pode ser descrito pela seguinte função de maximização:

$ \text{Maximizar} \sum_{i=1}^{n} v_i \cdot x_i $

sujeito a:

$\ \sum_{i=1}^{n} w_i \cdot x_i \leq W \$

onde ( $x_i$ ) é uma variável binária que indica se o item ($i$) está ou não incluído na mochila (1 se estiver incluído, 0 caso contrário).

O **Problema da Mochila** é conhecido por ser NP-difícil, o que significa que não se conhece um algoritmo eficiente para resolvê-lo em tempo polinomial para todos os casos.
"""

import random
import matplotlib.pyplot as plt

# Função de fitness - Calcula o valor total dos itens na mochila
def fitness(cromossomo, pesos, valores, capacidade):
    peso_total = sum(peso * cromossomo[i] for i, peso in enumerate(pesos))
    if peso_total > capacidade:
        return 0  # Solução inviável
    return sum(valor * cromossomo[i] for i, valor in enumerate(valores))

# Operação de mutação
def mutacao(cromossomo, taxa_mutacao):
    return [1 - gene if random.random() < taxa_mutacao else gene for gene in cromossomo]

# Operação de crossover
def crossover(pai1, pai2):
    ponto_corte = random.randint(1, len(pai1) - 1)  # Escolhe ponto de corte aleatório
    filho1 = pai1[:ponto_corte] + pai2[ponto_corte:]
    filho2 = pai2[:ponto_corte] + pai1[ponto_corte:]
    return filho1, filho2

# Seleção dos melhores indivíduos (roleta)
def selecao(populacao, fitness_populacao):
    if sum(fitness_populacao) == 0:
        return random.choice(populacao), random.choice(populacao)

    indices = list(range(len(populacao)))
    selecionados = random.choices(indices, weights=fitness_populacao, k=2)
    return populacao[selecionados[0]], populacao[selecionados[1]]

# Função para inicializar a população com maior diversidade
def inicializa_populacao(populacao_size, n):
    return [[random.randint(0, 1) for _ in range(n)] for _ in range(populacao_size)]

# Algoritmo Genético
def algoritmo_genetico(n, capacidade, pesos, valores, populacao_size=100, geracoes=200,
                       taxa_mutacao=0.05, taxa_crossover=0.7, elite_size=10):
    # Inicializa a população
    populacao = inicializa_populacao(populacao_size, n)

    # Lista para armazenar o melhor fitness de cada geração
    fitness_por_geracao = []

    for geracao in range(geracoes):
        # Calculando fitness para toda a população
        fitness_populacao = [fitness(individuo, pesos, valores, capacidade) for individuo in populacao]

        # Verificando a melhor solução na população
        melhor_fitness = max(fitness_populacao)
        melhor_individuo = populacao[fitness_populacao.index(melhor_fitness)]

        # Armazenando o melhor fitness de cada geração
        fitness_por_geracao.append(melhor_fitness)

        # Se atingir a solução ótima (fitness máximo), interrompe
        if melhor_fitness == sum(valores):
            break

        # Ordena a população com base no fitness (do melhor para o pior)
        populacao_ordenada = sorted(zip(populacao, fitness_populacao), key=lambda x: x[1], reverse=True)

        # Mantém os melhores 'elite_size' indivíduos (elitismo)
        nova_populacao = [individuo for individuo, _ in populacao_ordenada[:elite_size]]

        # Preenche o restante da população com cruzamento e mutação
        while len(nova_populacao) < populacao_size:
            pai1, pai2 = selecao(populacao, fitness_populacao)

            if random.random() < taxa_crossover:
                filho1, filho2 = crossover(pai1, pai2)
                nova_populacao.extend([filho1, filho2])
            else:
                nova_populacao.extend([pai1, pai2])

            # Aplica mutação
            nova_populacao = [mutacao(individuo, taxa_mutacao) for individuo in nova_populacao]

        # Trunca a nova população para garantir que tenha o tamanho correto
        populacao = nova_populacao[:populacao_size]

    # Resultado final
    fitness_populacao = [fitness(individuo, pesos, valores, capacidade) for individuo in populacao]
    melhor_fitness_final = max(fitness_populacao)
    melhor_individuo_final = populacao[fitness_populacao.index(melhor_fitness_final)]

    return melhor_individuo_final, melhor_fitness_final, fitness_por_geracao


# Parâmetros do problema
n = 10  # Número de itens
capacidade = 50  # Capacidade da mochila
pesos = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]  # Pesos dos itens
valores = [60, 100, 120, 160, 200, 240, 300, 400, 500, 600]  # Valores dos itens

# Executa o algoritmo genético
melhor_individuo, melhor_fitness, fitness_por_geracao = algoritmo_genetico(n, capacidade, pesos, valores)

# Exibe o resultado final
print(f"Melhor solução encontrada: {melhor_individuo} com valor total de {melhor_fitness}")

# Plotando o gráfico da evolução do fitness
plt.plot(fitness_por_geracao)
plt.title('Evolução do Melhor Fitness ao Longo das Gerações')
plt.xlabel('Gerações')
plt.ylabel('Melhor Fitness')
plt.grid(True)
plt.show()